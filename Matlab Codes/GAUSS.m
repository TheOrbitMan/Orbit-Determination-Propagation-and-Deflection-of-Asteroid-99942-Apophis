% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ function [r_old, v_old] = ...          GAUSS(Rho1, Rho2, Rho3, R1, R2, R3, jd1, jd2, jd3, mu,xi)%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%{  This function uses the Gauss method with iterative improvement  (Algorithms 5.5 and 5.6) to calculate the state vector of an  orbiting body from angles-only observations at three  closely-spaced times.  mu               - the gravitational parameter (au^3/day^2)  t1, t2, t3       - the times of the observations (day)  tau, tau1, tau3  - time intervals between observations (day)  R1, R2, R3       - the observation site position vectors                     at t1, t2, t3 (au)  Rho1, Rho2, Rho3 - the direction cosine vectors of the                     satellite at t1, t2, t3  p1, p2, p3       - cross products among the three direction                     cosine vectors  Do               - scalar triple product of Rho1, Rho2 and Rho3  D                - Matrix of the nine scalar triple products                     of R1, R2 and R3 with p1, p2 and p3  E                - dot product of R2 and Rho2  A, B             - constants in the expression relating slant range                     to geocentric radius  a,b,c            - coefficients of the 8th order polynomial                     in the estimated geocentric radius x  x                - positive root of the 8th order polynomial  rho1, rho2, rho3 - the slant ranges at t1, t2, t3  r1, r2, r3       - the position vectors at t1, t2, t3 (au)  r_old, v_old     - the estimated state vector at the end of                     Algorithm 5.5 (au, au/day)  User m-functions required:  -  User subfunctions required: posroot  This code is taken from:  Curtis, H. D.(2013) Orbital Mechanics for Engineering Students, 3. Edition, Elsevier.  Author: Curtis, H. D.%}% ------------------------------------------------------- k=1;%...Equations 5.98:tau1 = (jd1 - jd2)*k;tau3 = (jd3 - jd2)*k;%...Equation 5.101:tau  = tau3 - tau1;%...Independent cross products among the direction cosine vectors:p1 = cross(Rho2,Rho3);p2 = cross(Rho1,Rho3);p3 = cross(Rho1,Rho2);%...Equation 5.108:Do = dot(Rho1,p1);%...Equations 5.109b, 5.110b and 5.111b:D  = [[dot(R1,p1) dot(R1,p2) dot(R1,p3)]      [dot(R2,p1) dot(R2,p2) dot(R2,p3)]      [dot(R3,p1) dot(R3,p2) dot(R3,p3)]];    %...Equation 5.115b:E = dot(R2,Rho2);%...Equations 5.112b and 5.112c:A = 1/Do*(-D(1,2)*tau3/tau + D(2,2) + D(3,2)*tau1/tau);B = 1/6/Do*(D(1,2)*(tau3^2 - tau^2)*tau3/tau ...            + D(3,2)*(tau^2 - tau1^2)*tau1/tau);%...Equations 5.117:a = -(A^2 + 2*A*E + norm(R2)^2);b = -2*mu*B*(A + E);c = -(mu*B)^2;%NEWTON-RAPHSONerror=100;limit=10e-8;x=xi;while error>limit    x0=x;    x=x0-(x0^8+a*x0^6+b*x0^3+c)/(8*x0^7+6*a*x0^5+3*b*x0^2);    error=(abs(x-x0)/x0)*100;end%{%...Calculate the roots of Equation 5.116 using MATLAB's%   polynomial 'roots' solver:Roots = roots([1 0 a 0 0 b 0 0 c]);%...Find the positive real root:x = posroot(Roots);%}%...Equations 5.99a and 5.99b:f1 =    1 - 1/2*mu*tau1^2/x^3;f3 =    1 - 1/2*mu*tau3^2/x^3;%...Equations 5.100a and 5.100b:g1 = tau1 - 1/6*mu*(tau1/x)^3;g3 = tau3 - 1/6*mu*(tau3/x)^3;%...Equation 5.112a:rho2 = A + mu*B/x^3;%...Equation 5.113:rho1 = 1/Do*((6*(D(3,1)*tau1/tau3 + D(2,1)*tau/tau3)*x^3 ...               + mu*D(3,1)*(tau^2 - tau1^2)*tau1/tau3) ...               /(6*x^3 + mu*(tau^2 - tau3^2)) - D(1,1));           %...Equation 5.114:rho3 = 1/Do*((6*(D(1,3)*tau3/tau1 - D(2,3)*tau/tau1)*x^3 ...               + mu*D(1,3)*(tau^2 - tau3^2)*tau3/tau1) ...               /(6*x^3 + mu*(tau^2 - tau1^2)) - D(3,3));           %...Equations 5.86:r1 = R1 + rho1*Rho1;r2 = R2 + rho2*Rho2;r3 = R3 + rho3*Rho3;%...Equation 5.118:v2 = (-f3*r1 + f1*r3)/(f1*g3 - f3*g1);%...Save the initial estimates of r2 and v2:r_old = r2;v_old = v2;%{% ~~~~~~~~~~~~~~~~~~~~~~~~~~~  function x = posroot(Roots)% ~~~~~~~~~~~~~~~~~~~~~~~~~~~%{  This subfunction extracts the positive real roots from  those obtained in the call to MATLAB's 'roots' function.  If there is more than one positive root, the user is  prompted to select the one to use.   x         - the determined or selected positive root  Roots     - the vector of roots of a polynomial   posroots  - vector of positive roots  User M-functions required: none%}% ~~~~~~~~~~~~~~~~~~~~~~~~~~~%...Construct the vector of positive real roots:posroots  = Roots(find(Roots>0 & ~imag(Roots))); npositive = length(posroots);%...Exit if no positive roots exist:if npositive == 0    fprintf('\n\n ** There are no positive roots.  \n\n')    returnend%...If there is more than one positive root, output the%   roots to the command window and prompt the user to%   select which one to use:if npositive == 1    x = posroots;else    fprintf('\n\n ** There are two or more positive roots.\n')    for i = 1:npositive        fprintf('\n root #%g = %g',i,posroots(i))    end    fprintf('\n\n Make a choice:\n')    nchoice = 0;    while nchoice < 1 | nchoice > npositive        nchoice = input(' Use root #? ');    end    x = posroots(nchoice);    fprintf('\n We will use %g .\n', x)endend %posroot%}end %gauss% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~